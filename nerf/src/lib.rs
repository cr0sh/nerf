#![warn(clippy::print_stderr, clippy::print_stdout)]
//! nerf is a toolkit to create client-side SDK for (mainly) HTTP endpoint APIs.

mod error;
mod ready_call;

use std::future::Future;
use std::pin::Pin;

pub use ready_call::ReadyCall;

pub use bytes::Bytes;
pub use error::Error;
pub use http;
pub use nerf_macros::rate_limited;
pub use pin_project::pin_project;
pub use serde;
pub use serde_json;

/// Rate limit with weights.
pub trait WeightedRateLimit {
    fn weight(&self) -> u64;
}

/// Abstraction of `request` → [hyper::Client] → (server) → [hyper::Client] → [Response] flow.
///
/// [Response]: Request::Response
pub trait Request {
    /// 'Expected' response type. Error case should not be included here.
    /// TODO: introduce how to handle errors with `to
    type Response;
}

/// HTTP request metadata.
/// Usually autogenerated with attribute macros, e.g. [`nerf_macros::get`].
pub trait HttpRequest {
    fn uri(&self) -> http::Uri;
    fn method(&self) -> http::Method;
}

/// Clients that accept [Request]s.
pub trait Client<Req: Request> {
    /// The service wrapped by the client.
    type Service;
    type Error;
    /// A [Future] returned by [try_from_response].
    ///
    /// [try_from_response]: Client::try_from_response
    type TryFromResponseFuture: Future<Output = Result<Req::Response, Self::Error>>;

    /// Returns a mutable reference of the inner [Service] implementor.
    ///
    /// [Service]: tower::Service
    fn service(&mut self) -> &mut Self::Service;

    /// Wraps `self` to implement [Service].
    ///
    /// [Service]: tower::Service
    fn as_service(&mut self) -> AsService<'_, Self>
    where
        Self: Sized,
    {
        AsService { client: self }
    }

    fn try_into_request(&mut self, x: Req) -> Result<hyper::Request<hyper::Body>, Self::Error>;

    // FIXME: this should receive `&mut self` as `try_into_request` does, but the borrowck becomes unhappy
    // because  `tower::Service::Future` cannot hold a lifetime. Once GAT lands onto stable and tower::Service
    // GAT-ifies, we can consider adding `&mut self` to this method.
    fn try_from_response(x: hyper::Response<hyper::Body>) -> Self::TryFromResponseFuture;
}

pub struct AsService<'a, T> {
    client: &'a mut T,
}

impl<'a, Req, T, S> tower::Service<Req> for AsService<'a, T>
where
    Req: Request,
    T: Client<Req, Service = S>,
    T::Error: From<S::Error> + 'static,
    S: tower::Service<hyper::Request<hyper::Body>>,
    hyper::Response<hyper::Body>: From<S::Response>,
    S::Future: 'static,
{
    type Response = Req::Response;

    type Error = T::Error;

    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.client.service().poll_ready(cx).map_err(From::from)
    }

    fn call(&mut self, req: Req) -> Self::Future {
        let req = match self.client.try_into_request(req) {
            Ok(x) => x,
            Err(e) => return Box::pin(async move { Err(e) }),
        };
        let fut = self.client.service().call(req);
        Box::pin(async move { T::try_from_response(fut.await?.into()).await })
    }
}
